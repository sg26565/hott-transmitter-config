/**
 * HoTT Transmitter Config Copyright (C) 2013 Oliver Treichel
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package de.treichels.hott.model.serial;

import de.treichels.hott.model.HoTTException;
import de.treichels.hott.util.Util;
import jssc.SerialPortEvent;
import jssc.SerialPortEventListener;
import jssc.SerialPortException;
import jssc.SerialPortList;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.List;

import static jssc.SerialPort.*;

/**
 * @author Oliver Treichel &lt;oli@treichels.de&gt;
 *
 */
public class JSSCSerialPort implements SerialPort, SerialPortEventListener {
    private final class SerialPortInputStream extends InputStream {
        @Override
        public int available() {
            return readBuffer.available();
        }

        @Override
        public int read() throws IOException {
            // block until data is available
            while (readBuffer.available() == 0) {
                try {
                    readFromPort();
                } catch (final SerialPortException e) {
                    throw new IOException(e);
                }

                if (readBuffer.available() == 0) readBuffer.waitRead(1);
            }

            return readBuffer.read();
        }
    }

    private final class SerialPortOutPutStream extends OutputStream {
        @Override
        public void flush() throws IOException {
            try {
                writeToPort();
            } catch (final SerialPortException e) {
                throw new IOException(e);
            }
        }

        @Override
        public void write(final int b) throws IOException {
            if (writeBuffer.remaining() == 0) {
                flush();
                writeBuffer.waitWrite(1);
            }

            writeBuffer.write(b & 0xff);
        }
    }

    private static boolean DEBUG = Util.DEBUG;
    private static final int READ_BUFFER_SIZE = 4096;
    private static final int WRITE_BUFFER_SIZE = 4096;

    public static List<String> getAvailablePorts() {
        return Arrays.asList(SerialPortList.getPortNames());
    }

    private final ByteBuffer readBuffer = new ByteBuffer(READ_BUFFER_SIZE);
    private final ByteBuffer writeBuffer = new ByteBuffer(WRITE_BUFFER_SIZE);

    public void setName(String name) {
        this.name = name;
    }

    /** The name of the serial port. */
    private String name;

    /** The internal low-level serial port implementation. */
    private jssc.SerialPort port = null;

    public JSSCSerialPort() {
        this(null);
    }

    public JSSCSerialPort(final String name) {
        this.name = name;
    }

    @Override
    public void close() throws HoTTException {
        try {
            if (isOpen()) port.closePort();
        } catch (final SerialPortException e) {
            throw new HoTTException(e);
        } finally {
            port = null;
        }
    }

    @Override
    public InputStream getInputStream() {
        return new SerialPortInputStream();
    }

    public String getName() {
        return name;
    }

    @Override
    public OutputStream getOutputStream() {
        return new SerialPortOutPutStream();
    }

    @Override
    public String getPortName() {
        return name;
    }

    @Override
    public boolean isOpen() {
        return port != null && port.isOpened();
    }

    @Override
    public void open() throws HoTTException {
        if (isOpen()) throw new HoTTException("HoTTSerialPort.AlreadyOpen");

        try {
            port = new jssc.SerialPort(name);
            port.openPort();
            port.setParams(BAUDRATE_115200, DATABITS_8, STOPBITS_1, PARITY_NONE, false, false);
            port.setFlowControlMode(FLOWCONTROL_NONE);
            port.addEventListener(this, MASK_RXCHAR + MASK_TXEMPTY);
        } catch (final SerialPortException e) {
            throw new HoTTException(e);
        }
    }

    private synchronized void readFromPort() throws SerialPortException {
        if (DEBUG) System.out.printf("readFromPort: %d bytes available%n", port.getInputBufferBytesCount());

        final byte[] bytes = port.readBytes();
        if (DEBUG) System.out.println(Util.dumpData(bytes));

        if (bytes != null) readBuffer.write(bytes);
    }

    @Override
    public void reset() throws HoTTException {
        try {
            readBuffer.reset();
            writeBuffer.reset();
            port.purgePort(PURGE_RXABORT + PURGE_RXCLEAR + PURGE_TXABORT + PURGE_TXCLEAR);
        } catch (final SerialPortException e) {
            throw new HoTTException(e);
        }
    }

    @Override
    public void serialEvent(final SerialPortEvent event) {
        if (DEBUG) System.out.printf("serialEvent: port=%s, type=%s(%d), value=%d%n", event.getPortName(), event.getEventType() == 1 ? "RXCHAR" : "TXEMPTY",
                event.getEventType(), event.getEventValue());

        try {
            if (event.isRXCHAR()) readFromPort();

            if (event.isTXEMPTY()) writeToPort();
        } catch (final SerialPortException e) {
            throw new RuntimeException(e);
        }
    }

    private synchronized void writeToPort() throws SerialPortException {
        final int available = writeBuffer.available();

        if (available > 0) {
            if (DEBUG) System.out.printf("writeToPort: %d bytes to write%n", available);
            // write max 512 bytes to serial port
            final byte[] bytes = new byte[Math.min(available, 512)];
            writeBuffer.read(bytes);
            if (DEBUG) System.out.println(Util.dumpData(bytes));
            port.writeBytes(bytes);
        }
    }
}
